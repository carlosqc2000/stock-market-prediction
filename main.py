import argparse
from typing import Dict, Any
from src.get_prices import get_prices
from src.get_news import get_news
from src.train_model import train_model
from src.make_prediction import make_prediction
from database.mongo_db.repository import MongoRepository
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
import joblib
from datetime import datetime
from src.preprocessing import preprocess_data

# Initialize repository instance
repo = MongoRepository()

def save_data(symbol: str, data: Dict[str, Any], data_type: str) -> None:
    """
    Save data into the appropriate collection in MongoDB.

    Args:
        symbol (str): The company symbol (e.g., AAPL).
        data (Dict[str, Any]): The data to be saved.
        data_type (str): The type of data ('prices' or 'news').

    Raises:
        ValueError: If the data_type is invalid.
    """
    try:
        if data_type == "prices":
            repo.create_price(data)
        elif data_type == "news":
            repo.create_news(data)
        else:
            raise ValueError("Invalid data type. Must be 'prices' or 'news'.")
        print(f"Data successfully saved for {symbol} in {data_type} collection.")
    except Exception as e:
        print(f"Error saving data for {symbol} in {data_type} collection: {e}")

def download_data(symbol: str) -> None:
    """
    Download price and news data for a specific company.

    Args:
        symbol (str): The company symbol (e.g., AAPL).
    """
    try:
        # Fetch prices
        prices = get_prices(symbol)
        if prices:
            for price in prices:
                save_data(symbol, price, "prices")
        else:
            print(f"No price data available for {symbol}.")

        # Fetch news
        news = get_news(symbol)
        if news:
            for news_item in news:
                save_data(symbol, news_item, "news")
        else:
            print(f"No news data available for {symbol}.")

        print(f"Data successfully downloaded and saved for {symbol}.")
    except Exception as e:
        print(f"Error downloading data for {symbol}: {e}")
        raise

def train(symbol: str) -> None:
    """
    Train a prediction model for a specific company.

    Args:
        symbol (str): The company symbol (e.g., AAPL).
    """
    try:
        # Fetch and deduplicate data
        prices = list(repo.db.Prices.find({"symbol": symbol}))
        df = pd.DataFrame(prices).drop_duplicates(subset=["date"])  # Deduplicate by date

        # Proceed with the rest of the training logic
        X = df[["open", "high", "low", "volume"]]
        y = df["close"]

        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        model = RandomForestRegressor()
        model.fit(X_train, y_train)

        # Save the trained model
        joblib.dump(model, f"models/{symbol}_model.pkl")
        print(f"Model successfully trained for {symbol}.")
    except Exception as e:
        print(f"Error training the model for {symbol}: {e}")
        raise

def predict(symbol: str) -> str:
    """
    Generate a prediction based on the trained model for a specific company.

    Args:
        symbol (str): The company symbol (e.g., AAPL).

    Returns:
        str: Prediction generated by the model.
    """
    try:
        # Load trained model
        model = joblib.load(f"models/{symbol}_model.pkl")

        # Fetch latest data
        latest_data = repo.db.Prices.find_one({"symbol": symbol}, sort=[("date", -1)])
        if not latest_data:
            raise ValueError(f"No data found for {symbol} to make a prediction.")

        df = pd.DataFrame([latest_data])
        X = df[["open", "high", "low", "volume"]]

        # Make prediction
        prediction = model.predict(X)[0]
        print(f"Prediction for {symbol}: {prediction}")
        return prediction
    except Exception as e:
        print(f"Error generating prediction for {symbol}: {e}")
        raise

def main() -> None:
    """
    Main entry point of the program. Manages the main logic and command-line arguments.
    """
    # Configure command-line arguments
    parser = argparse.ArgumentParser(description="Stock market prediction tool.")
    parser.add_argument("action", choices=["download", "train", "predict", "preprocess"], help="Action to perform")
    parser.add_argument("symbol", help="Company symbol (e.g., AAPL)")
    args = parser.parse_args()

    try:
        if args.action == "download":
            download_data(args.symbol)
        elif args.action == "train":
            train(args.symbol)
        elif args.action == "predict":
            result = predict(args.symbol)
            print(f"Prediction for {args.symbol}: {result}")
        elif args.action == "preprocess":
            preprocess_data(args.symbol)
        else:
            print("Invalid action. Use 'download', 'train', 'predict', or 'preprocess'.")
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    main()
